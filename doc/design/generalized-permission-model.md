# Generalized Permission Model

For a long time, the DANDI Archive has featured a very simple, largely "hard
coded" permission model. With recent needs to deploy the DANDI Archive
infrastructure to different projects with different permissions requirements,
the time has come to address a more generalized permissions model that can cover
DANDI's "simple" requirements as well as the more complex requirements of
projects such as LINC and EMBER (as well as complexifying requirements that may
arise for DANDI itself).

This document lays out the history of permissions in DANDI Archive followed by a
proposal for a general permissions system, some discussion of how it may be
implemented, and finally a list of requirements. (The history section motivates
the need for the proposed permissions system, but is not essential to
understanding the proposal; accordingly, feel free to skip it or read it later.)

## History and Current Status

The DANDI Archive's original mission requires only a very simple permissions
model: by default, all Dandisets are available for viewing and download to all
users (even unauthenticated ones); all modifying operations on a given Dandiset
can only be performed by the *owners* of that Dandiset. Dandisets can be created
by any authenticated user; the act of creation, by definition, makes the
creating user an owner of that Dandiset (and an owner may make other users
owners of a Dandiset they own).

The model is thus quite simple: read-type operations need not be guarded by any
authorization checks at all, and write-type operations only need to check
whether the Dandiset in question has the user listed as one of its owners. This
simplicity is possible because of the DANDI Archive's status as an NIH data
archive promoting open access to data generated by NIH-funded neuroscience
research.

(Our model also includes an *admin* role, which receives all permissions in the
system. This is a general feature of many permission models, akin to the
superuser in UNIX systems, and can largely be ignored when discussing the
particular features of DANDI's model.)

### The first quirk: embargo

NIH allows for an *embargo period* during which a scientist’s data may be kept
private, enabling a finite time to publish papers, etc., before becoming public.
This trades a period of secrecy for a promise of openness in perpetuity to
promote the best interests of both the scientists generating the data and the
wider public.

The Archive implements embargo, keeping an embargoed Dandiset hidden from public
view for a time. Owners of the Dandiset continue to have read and write access,
but the permissions model grew a wart to cover this case: now, read-type
operations must also check whether the target Dandiset is marked as *embargoed*,
gating access to only owners of the Dandiset.

In a "hard coded" permission model, this is actually not too bad; unfortunately,
there’s more.

### The second quirk: viewers/reviewers

With embargo, the permissions model meets NIH’s requirements. But certain
quality of life improvements become impossible. For example, owners of an
embargoed Dandiset may wish to share read-only access to a selected set of
colleagues. This is only possible in the existing model by granting full
ownership; instead, it would be helpful to assign them as *viewers*.

A similar role could be useful in a blind review workflow: a *reviewer* who has
read-only access but whose identity is not visible to the owners. This would be
controlled by admins rather than Dandiset owners (drawing a specific distinction
between those roles).

### The quirk that broke the camel's back: other archives

Finally, in recent months, the DANDI team has been investigating whether the
DANDI Archive codebase can serve the data archival needs of related neuroscience
projects, specifically LINC and EMBER.

The LINC and EMBER archives must store datasets that can only be accessed by
appropriate project personnel. While embargo can protect these datasets from
public access, easily sharing access to the intended userbase becomes difficult.
These archives, essentially, do not share the open-by-default character of
DANDI, and this is reflected in the hard-coded permission model.

Conceivably, other projects might also want to use the same infrastructure in
new ways. What is needed now is a general model of permissions management that
(1) covers the original DANDI permission model; (2) can be extended on a
per-deployment basis to use cases such as LINC, EMBER, and others; (3) does not
compromise correctness, usability, or performance; and (4) involves a
fundamental, coherent theory of permissions at the "atomic" level on which these
extensions can be built.

### Current status

At the moment, the permissions model is largely hard-coded into the DANDI
Archive codebase. Dandisets carry an attribute indicating whether they are
*open* or *embargoed*, and the database records whether a given user is an
*owner* of a given Dandiset. Certain users are marked as *admin*.

Read access to a Dandiset is granted to a user if: (1) the Dandiset is open; or
(2) the Dandiset is embargoed and the user is an owner; or (3) the user is an
admin.

Write access is granted if: (1) the user is an owner of the Dandiset; or (2) the
user is an admin. Note that "write access" includes operations such as uploading
assets to a Dandiset, editing its metadata, and publishing the Dandiset.

These notions of read and write access, together with the logic described above,
constitute the current permissions model.

## New Permissions Model

The new permissions model for the DANDI Archive consists of a collection of
*atomic permissions*, representing the authorization to take specific actions in
the system, that are used to gate access to API endpoints fulfilling those
actions. An example permission is *view*, which enables read operations on a
Dandiset (enabling read-only access to, e.g., Dandiset metadata and assets).

These permissions are not granted directly to users, but rather mediated through
*roles*. A role is a named collection of permissions granting a user structured
access to a Dandiset for some specific purpose. For instance, the current
model's concept of a Dandiset owner could be expressed through an *owner* role,
which would grant all relevant permissions on a specific Dandiset. The current
model explicitly recognizes an owner of a Dandiset and implicitly grants all
access; in the new model, "all access" would be carefully designed as a
collection of specific permissions.

### Atomic permissions

The atomic permissions represent the specific, narrow permission to take
individual actions on a Dandiset. The following table lists the set of
permissions:

| **Permission**  | **Definition**                             |
| --------------- | ------------------------------------------ |
| `view`          | Read a Dandiset's metadata and assets      |
| `edit_metadata` | Edit a Dandiset's metadata                 |
| `add_asset`     | Upload assets to a Dandiset                |
| `remove_asset`  | Delete assets from a Dandiset              |
| `unembargo`     | Unembargo a Dandiset                       |
| `publish`       | Create a published version of a Dandiset   |
| `delete`        | Delete a (deleteable) Dandiset             |
| `manage_roles`  | Add/remove roles from users for a Dandiset |

These permissions will form part of the logic for determining whether to fulfill
or deny a request made through the API. For example, the `GET
/dandisets/{id}/metadata` endpoint relies on the requesting user having the
`view` permission. However, the DANDI model requires that Dandisets in the
`open` state (i.e., not embargoed) be readable by all users, so the logic for
granting access to the metadata would be something like `dandiset.open or
has_permission(Permission.view, user, dandiset)`. This is an example of
"attribute based access control" (or "ABAC"), in which access controls are a
function of the user making a request, the resource and action being requested,
and a full set of attributes on each of those entitites.

The `view` permission is likely to be special in this way; most or all of the
others will feature simpler logic that looks more like, e.g.,
`has_permission(Permission.publish, user, dandiset)`. Another possible example
is a `view_restricted_asset` permission, which would grant read access to assets
that are marked as `restricted`. The logic for such an asset read request might
look like `has_permission(Permission.view_restricted_asset, user) if
asset.restricted else has_permission(Permission.view, user, dandiset)`.

Note also that there is no `create` permission: in the current model, the
permission to create Dandisets is inherently granted to all users. Beyond that,
semantically, it is not a permission that applies to any particular Dandiset,
but is rather a "system permission" granted to the user (we might nonetheless
use the “global permission” implementation to register such permissions). Such a
permission might be useful to include, but at the current time we are
deliberately leaving it to the side.

### Roles

The atomic permissions above are not granted directly to users. Instead,
collections of permissions are bundled into named roles, and those roles are
then granted to users for a particular Dandiset. As an example, a role called
`reader` might be defined as consisting only of the `view` permission. If this
role is granted to a user for Dandiset 123, then that user will be able to view
Dandiset 123's metadata and assets, but not carry out other operations such as
publishing, deleting/adding assets, etc. A role called `owner` might consist of
all eight permissions listed above, conferring the full amount of power over a
Dandiset (including the ability to add other owners through the `manage_roles`
permission, etc.).

Roles can also be granted in a special way to confer enhanced powers; by
granting a role to a user *without* specifying a particular Dandiset, the user
gains that role over *all* Dandisets. This is a "global role" and can be useful
for creating special, admin-style users. For example, granting a user the
`owner` role in this way creates a superuser who can carry out any action on any
Dandiset. A global version of the `viewer` role would be useful for specific
users who need to, e.g., generate a report on data usage across the whole
archive (an NIH representative, perhaps).

Roles can be administered by giving a specification file to a specific Django
management command that will do the necessary work to create any new roles in
the system, set up the needed Django groups (see [implementation
notes](#implementation-notes) below), etc. An example of such a file might be:

```yaml
name: owner
permissions:
  - view
  - edit_metadata
  - add_asset
  - remove_asset
  - unembargo
  - publish
  - delete
  - manage_roles

```

or

```yaml
name: asset_manager
permissions:
  - view
  - add_asset
  - remove_asset

```

These can be defined per-instance, per the needs of the specific archive.

## Reimplementing the Current Model

Under the new model, we can think about how to construct the currently existing
model for the DANDI Archive (including desired features that do not currently
exist), as well as the LINC and EMBER Archives.

One common role that will be useful to all archives is *admin*, a role that has
all possible powers. Currently, the DANDI Archive abuses the Django superuser
status for this purpose. In the new model, a role named `admin` that has all
permissions would be a suitable definition. Assigning a user to this role for a
specific Dandiset would make that user an "admin" for the Dandiset--essentially,
an owner thereof, but without appearing in the actual list of owners. More
commonly, such a role would be assigned "at large", making the user an
administrator for the entire archive.

Another is `owner` which, as discussed above, might be defined the same way as
`admin`. Generally, you would not want to assign this role "at large", as there
does not seem to be a great use case for making a user an owner of every
Dandiset in the system. Of course, there may be such a case, and if so, it is
possible to do.

### DANDI

The *admin* and *owner* roles as described above are sufficient to recover
DANDI's core permissions setup. Open Dandisets will be viewable by everyone,
while embargoed Dandisets will only be viewable to their owners (since they have
the `view` permission). The following are some concepts that could be
implemented to extend the setup.

**Viewer.** The *viewer* role is intended for sharing access to embargoed
Dandisets without granting full ownership-level access. This role would have
just the `view` permission, and granting it to a user on a Dandiset would
therefore enable them to examine the Dandiset when it is embargoed. Anyone with
the `manage_roles` permission on that Dandiset—generally, its owners—can add and
remove viewers, granting the owners the power to share read-only access with
colleagues, temporary students in the lab, etc.

**Reviewer.** The *reviewer* role is a little bit trickier. It is the same as
*viewer*, except that reviewers' identities must be hidden from
non-administrative users. In particular, the review process for a submitted
manuscript might require the paper reviewers to gain access to the associated
Dandiset without revealing their identities to the Dandiset owners. This could
be accomplished by including an `invisible` property on the role definition,
together with a `view_invisible_roles` permission that would be part of the
*admin* role (but not *owner*).

**Other specialized roles.** Roles such as "publisher", "asset manager",
"reporter", etc. are now possible simply by defining roles with a subset of the
full permission list. The possibilities here are bounded only by the power set
of the permissions and the needs of the archive administrators.

## LINC and EMBER

The LINC and EMBER Archive has a fundamental need to only allow users that are
part of the LINC project to view LINC datasets. This can be accomplished with
the *owner* and *viewer* roles described above, plus careful management of the
set of owners and viewers of LINC Dandisets. This might be made easier by
introducing the concept of *user groups* to the system as well; then an admin
could create a "LINC Personnel" group, add specific users to it, and then assign
appropriate roles to that group (instead of individually to many users). Such a
concept would mesh well with the permissions model proposed here, but
nonetheless lies outside its scope as well.

EMBER has a potential need for "closed" datasets (i.e., datasets not viewable by
anyone except those granted `view` permission by the owners, that nonetheless do
not have embargo logic for automatic, time-based unembargo attached to them). To
extend to this use case, we would need to refine DANDI's model that everything
is either open or embargoed, to one in which everything is either open or
closed, and closed Dandisets can have extra logic attached to them for
rule-based workflows such as embargo. However, that too is outside the scope of
the current design, and is mentioned here only to lay theoretical groundwork for
the future.

## Implementation Notes

We intend to implement the set of permissions as Django permissions, while roles
will be implemented as Django groups. The system will define one group for each
pairing of Dandiset and role (with new such groups being created along with new
Dandisets, and destroyed when Dandisets are deleted), and users will be assigned
a role by being added to the appropriate group.

This will enable the system to make use of the `django-guardian` library to
carry out permissions-based authorization.

## Requirements

Requirements usually come earlier than the end in these documents. However, in
this case the ideas needed more clarity up front, and the following requirements
may in fact seem obvious now that the discussion has happened.

1. **Definition and deployment of atomic permissions.** The *atomic permissions*
   discussed [above](#atomic-permissions) will be defined in the system and used
   to gate access to the API endpoints so that only those users who have the
   appropriate permission can execute each endpoint.
2. **Use of roles to assign permissions.** Each deployment of the DANDI Archive
   will be configured with one or more *roles*, defined [above](#roles) as
   collections of permissions. Roles that will come built in will include
   *owner* (which has all permissions for a specific Dandiset) and *admin*
   (which has all permissions for all Dandisets).
3. **Role management.** The DANDI Archive will gain UI for users with the
   `manage_roles` permission to modify which roles users have on Dandisets under
   their control. Admin users may get a separate UI (or a view in the admin
   console) to modify roles globally.
4. **Role administration.** The Archive will have configuration methods to
   control which roles exist, and what their definitions are. This may take the
   form of a management command that accepts a YAML or JSON specification,
   creates and deletes roles according to the information in it, and
   automatically updates existing user role assignments, etc. This command may
   also yield such a YAML/JSON file describing the current role configuration.
5. **Performance (non-functional requirement).** The performance of the system
   under the new model should not be significantly different from the current
   implementation. Retrieving lists of publicly accessible (i.e., "open")
   Dandisets, and lists of Dandisets owned by a given user should both continue
   to function with essentially the same performance as now. Retrieving a list
   of all Dandisets *viewable by* a given user, will likely be slower than the
   equivalent operation today (since, under the current model, "viewable by the
   user" is the same as "concatenation of open and owned Dandisets"). We will
   conduct performance testing to ensure the bounds of this slowdown.
