# Generated by Django 4.2.23 on 2025-08-11 17:13
from __future__ import annotations

from typing import TYPE_CHECKING

from django.db import migrations, models
from django.db.models.fields.json import KeyTextTransform
from django.db.models.functions import Cast, Coalesce

if TYPE_CHECKING:
    from django.apps.registry import Apps

    from dandiapi.api.models.audit import AuditRecordType


def backfill_asset_audit_record_sizes(apps: Apps, schema_editor):
    Asset = apps.get_model('api.Asset')
    AuditRecord = apps.get_model('api.AuditRecord')

    asset_record_types: list[AuditRecordType] = ['add_asset', 'update_asset', 'remove_asset']

    asset_records = AuditRecord.objects.filter(
        record_type__in=asset_record_types,
    ).annotate(
        # Extract the asset_id out of the `details` json column and cast it to a UUID so
        # that it can be compared against the actual `Asset.asset_id` field
        asset_id=Cast(
            expression=KeyTextTransform('asset_id', 'details'),
            output_field=models.UUIDField(),
        ),
    )

    audit_asset_ids = asset_records.values_list('asset_id', flat=True)

    assets_with_audit_records = Asset.objects.filter(asset_id__in=audit_asset_ids)

    if assets_with_audit_records.count() != audit_asset_ids.distinct('asset_id').count():
        raise RuntimeError('Assets table does not align with existing asset audit records')

    asset_records.update(
        details=models.Func(
            models.F('details'),
            models.Value('{size}'),
            models.Func(
                models.Subquery(
                    assets_with_audit_records.filter(
                        asset_id=models.OuterRef('asset_id'),
                    ).values(size=Coalesce('blob__size', 'zarr__size'))[:1]
                ),
                function='to_jsonb',
            ),
            function='jsonb_set',
            output_field=models.JSONField(),
        )
    )


class Migration(migrations.Migration):
    dependencies = [
        ('api', '0024_remove_assetblob_unique_etag_size_and_more'),
    ]

    operations = [
        migrations.RunPython(
            code=backfill_asset_audit_record_sizes,
            reverse_code=migrations.RunPython.noop,
        )
    ]
